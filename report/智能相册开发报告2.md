<h1>智能相册开发报告2</h1>
<h2>需求</h2>
在智能相册android客户端的基础上，跟摄像头结合，实现摄像头拍摄照片能够实时提交服务端识别，并把服务端返回结果呈现出来。
<h2>详细要求</h2>
智能相册客户端能基于http调用接口，上传图片，拿到结果(json格式)，并显示

<h2>成果展示</h2>
<div align = center>
    <img src="https://raw.githubusercontent.com/zhengxq27/intelligent-album/master/picture/7.png" height = 300 width = 180 />
    <img src="https://raw.githubusercontent.com/zhengxq27/intelligent-album/master/picture/8.png" height = 300 width = 180 />
    <img src="https://raw.githubusercontent.com/zhengxq27/intelligent-album/master/picture/9.png" height = 300 width = 180 />
     <img src="https://raw.githubusercontent.com/zhengxq27/intelligent-album/master/picture/10.png" height = 300 width = 180 />
</div>

<h2>开发过程详述</h2>

- 修改布局文件如下：
``` xml
<?xml version="1.0" encoding="utf-8"?>
<android.support.percent.PercentRelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto">


    <android.support.v7.widget.RecyclerView
        android:id="@+id/rv_images_1"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_heightPercent="92%" />

    <LinearLayout
        app:layout_heightPercent="8%"
        android:background="#BEBEBE"
        android:layout_width="match_parent"
        android:layout_below="@id/rv_images_1">

        <de.hdodenhof.circleimageview.CircleImageView
            android:id="@+id/camear_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:foregroundGravity="center"
            android:src="@drawable/camera1"
            app:civ_border_color="#FF000000"
            app:civ_border_width="0dp" />
    </LinearLayout>

</android.support.percent.PercentRelativeLayout>
```
- 添加事件调用摄像头
``` java
     camera_button = root.findViewById(R.id.camear_button);
        camera_button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                new Thread(){ //开启一个新线程来完成这个工作，避免主线程负担太大
                    @Override
                    public void run() {
                        takePhoto();
                    }
                }.start();
            }
        });
```
``` java
 public void takePhoto(){
        Intent intent = new Intent("android.media.action.IMAGE_CAPTURE");
        startActivityForResult(intent, CROP_PHOTO);
    }
```
- 重载onActivityResult函数，对Intent中的数据进行处理
``` java
@Override
    public void onActivityResult(int req, int res, Intent data){
        switch (req){
            case CROP_PHOTO:
                final Intent Data = data;
                new Thread(){
                    @Override
                    public void run() {
                        UploadCameraImage(Data);
                    }
                }.start();

                break;
            default:
                break;

        }
    }
``` 
- 将拍照得到的数据上传到服务器端，显示返回结果。
    - 首先将摄像头拍到的数据以file的形式保存在本地
    ``` java
     if (!Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED)) {
            Log.i(TAG, "sd card is not avaiable/writeable right now.");
            return;
        }

        Bitmap bmp = (Bitmap) data.getExtras().get("data");// 解析返回的图片成bitmap

        FileOutputStream Image = null;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd-HH:mm");
        String imageName = sdf.format(Calendar.getInstance().getTime()) + ".jpg";

        File file = new File("/mnt/sdcard/intelligentAlbum/");
        file.mkdirs(); //创建文件夹
        imageName = "/mnt/sdcard/intelligentAlbum/" + imageName;//完整的路径

        try {// 写入SD card
            Image = new FileOutputStream(imageName);
            bmp.compress(Bitmap.CompressFormat.PNG, 100, Image);
            if (Image != null) {
                Log.d("Image", "saveCameraImage: Image is not null");
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            try {
                Image.flush();
                Image.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    ```
    - 使用retrofit2建立http请求,首先添加retrofit2依赖
    ``` java

    ```
    -  创建MyService接口
    ```java
    package com.study.sysu.photo;

    import okhttp3.MultipartBody;
    import okhttp3.RequestBody;
    import okhttp3.ResponseBody;
    import retrofit2.Call;
    import retrofit2.http.Multipart;
    import retrofit2.http.POST;
    import retrofit2.http.Part;

    public interface MyService {

        @Multipart
        @POST("/uploadImage")
        Call<Object> upload(@Part("description") String description,
                                @Part MultipartBody.Part file);
    }
    ```
    - 将图片封装进MultipartBody.Part中
    ``` java
     //按照格式封装数据
        RequestBody requestFile = RequestBody.create(MediaType.parse("image/jpg"), file1);
        MultipartBody.Part body = MultipartBody.Part.createFormData("file", file1.getName(), requestFile);
        String descriptionString = "this is photo description";
    ```
    - 使用retrofit发送http请求，上传图片
    ``` java
    OkHttpClient build = new OkHttpClient.Builder()
                .connectTimeout(2, TimeUnit.SECONDS)
                .readTimeout(2, TimeUnit.SECONDS)
                .writeTimeout(2, TimeUnit.SECONDS)
                .build();

        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("http://192.168.2.183:8080")
                .addConverterFactory(GsonConverterFactory.create())
               // .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                // build 即为okhttp声明的变量，下文会讲
                .client(build)
                .build();

        MyService myService = retrofit.create(MyService.class);
        Call<Object> myCall = myService.upload(descriptionString,body);
    ```
    - 请求成功时回调
    ``` java
    myCall.enqueue(new Callback<Object>() {
            //请求成功时回调
            @Override
            public void onResponse(Call<Object> call, final Response<Object> response) {
                // 步骤7：处理返回的数据结果
                if( response.body() != null){
                    Log.d("reply", "onResponse: " + response.toString());
                    Toast.makeText(getActivity(),"图片分类成功，分类结果为：XXX",Toast.LENGTH_SHORT).show();
                }
                else{
                    Log.d("reply", "onResponse: null");
                    Toast.makeText(getActivity(),"图片分类失败",Toast.LENGTH_SHORT).show();
                }
            }
            //请求失败时回调
            @Override
            public void onFailure(Call<Object> call, Throwable throwable) {
                System.out.println("连接失败");
            }
        });
    ```
<h2>自定义服务端</h2>
使用java后台的Springboot框架自定义一个简单自定义服务端,接受前端发过来的图片判断是否成功发送并返回结果，ImageController简单定义如下：

``` java
@Controller
public class ImageController {

    @RequestMapping(value="/uploadImage", method = RequestMethod.POST)
    @ResponseBody
    public ResponseEntity<Object> checkImage(@RequestParam("file") MultipartFile file) {

        if (!file.isEmpty()) {
            return new ResponseEntity(new ReturnMsg("uploadimg success"), HttpStatus.OK);
        }
        else {
            return new ResponseEntity(new ReturnMsg("uploadimg fail"), HttpStatus.BAD_REQUEST);
        }
        //return new ResponseEntity(new ReturnMsg("server error, delete fail"), HttpStatus.OK);
    }
}
```
定义ReturnMsg类如下：
``` java
public class ReturnMsg {
    private String msg;

    public ReturnMsg(String msg)
    {
        this.msg = msg;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}
```
上传图片成功返回的json数据如下:<br />
<div align = center>
<img src="https://raw.githubusercontent.com/zhengxq27/intelligent-album/master/picture/11.png" height =  width = 180 />
</div>
 



    

