<h1>智能媒体平台之安卓智能相册开发报告</h1>
<h2>一、开发内容简介</h2>
安卓智能相册开发是智能媒体平台开发可视化内容的一部分，通过自主开发一个安卓相册客户端，将其与智能平台开发的算法相结合，实现人脸识别、人脸检测、图像分类功能的可视化呈现，使我们能够直观地查看与检验智能算法的功能和准确性。
<h2>二、开发内容要求</h2>
智能相册APP参照华为系统相册的样式和功能，主要分为三部分内容：<br/>

- 照片：显示手机存储的所有图片
- 相册：将手机的所有图片按不同的相册分类，点击各个相册查看其包含图片
- 发现：根据智能算法对手机存储中的所有图片进行整理与分类，例如“人像”、“地点”、“事物”等

华为系统相册样式如下：<br/>
<center>
    <img src="https://raw.githubusercontent.com/zhengxq27/intelligent-album/master/picture/%E5%9B%BE%E7%89%87.jpg" height = 300 width = 180 />
    <img src="https://raw.githubusercontent.com/zhengxq27/intelligent-album/master/picture/%E7%9B%B8%E5%86%8C.jpg" height = 300 width = 180 />
    <img src="https://raw.githubusercontent.com/zhengxq27/intelligent-album/master/picture/%E5%8F%91%E7%8E%B0.jpg" height = 300 width = 180 />
</center>

<h2>三、智能相册开发成果展示</h2>
<center>
    <img src="https://raw.githubusercontent.com/zhengxq27/intelligent-album/master/picture/%E7%85%A7%E7%89%87.jpg" height = 300 width = 180 />
    <img src="https://raw.githubusercontent.com/zhengxq27/intelligent-album/master/picture/%E7%9B%B8%E5%86%8C1.jpg" height = 300 width = 180 />
</center>

<h2>四、开发过程详述</h2>
<h3>(1)顶部导航栏的实现</h3>
顶部导航栏借用了github上的一个开源第三方库wasabeef/awesome-android-ui实现，选取其中的SmartTabLayout控件，注意这里有andoridx和legacy android support library版本，我选取的是legacy android support library版本，具体实现如下：

1. build.gradle文件添加依赖
``` java
dependencies {
    compile 'com.ogaclejapan.smarttablayout:library:1.7.0@aar'

    //Optional: see how to use the utility.
    compile 'com.ogaclejapan.smarttablayout:utils-v4:1.7.0@aar'

    //Deprecated since 1.7.0
    compile 'com.ogaclejapan.smarttablayout:utils-v13:1.7.0@aar'
} 
```
2. activity_main.xml文件添加代码如下：
``` xml
<com.ogaclejapan.smarttablayout.SmartTabLayout
        android:id="@+id/viewpagertab"
        android:layout_width="match_parent"
        android:layout_height="48dp"
        app:stl_indicatorAlwaysInCenter="false"
        app:stl_indicatorWithoutPadding="false"
        app:stl_indicatorInFront="true"
        app:stl_indicatorInterpolation="smart"
        app:stl_indicatorGravity="bottom"
        app:stl_indicatorColor="#40C4FF"
        app:stl_indicatorThickness="3dp"
        app:stl_indicatorWidth="auto"
        app:stl_indicatorCornerRadius="2dp"
        app:stl_overlineColor="@color/white"
        app:stl_overlineThickness="0dp"
        app:stl_underlineColor="@color/white"
        app:stl_underlineThickness="1dp"
        app:stl_dividerColor="@color/white"
        app:stl_dividerThickness="1dp"
        app:stl_defaultTabBackground="?attr/selectableItemBackground"
        app:stl_defaultTabTextAllCaps="true"
        app:stl_defaultTabTextColor="#FC000000"
        app:stl_defaultTabTextSize="16sp"
        app:stl_defaultTabTextHorizontalPadding="50dp"
        app:stl_defaultTabTextMinWidth="50dp"
        app:stl_distributeEvenly="true"
        app:stl_clickable="true"
        app:stl_titleOffset="24dp"
        app:stl_drawDecorationAfterTab="false"
        />

    <android.support.v4.view.ViewPager
        android:id="@+id/viewpager"
        android:layout_marginTop="48dp"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@id/viewpagertab"
        />

```
3. MainActivity.java文件设置Adapter和ViewPager,代码如下：
``` java
FragmentPagerItemAdapter adapter = new FragmentPagerItemAdapter(
                getSupportFragmentManager(), FragmentPagerItems.with(this)
                .add("照片", PageFragment1.class)
                .add("相册", PageFragment2.class)
                .add("发现", PageFragment3.class)
                .create());

        ViewPager viewPager = (ViewPager) findViewById(R.id.viewpager);
        viewPager.setAdapter(adapter);

        SmartTabLayout viewPagerTab = (SmartTabLayout) findViewById(R.id.viewpagertab);
        viewPagerTab.setViewPager(viewPager);
```
到这里就顺利完成了顶部导航栏的实现。
<hr />

<h3>2.实现照片栏展示手机存储中的所有图片</h3>
要展示手机中存储的所有图片，首先我们需要成功获取到手机中所有图片的路径，通过图片路径访问图片并把图片加载出来。这个功能的实现主要分为以下几个步骤：

1. 动态申请读取存储权限
``` java
public static void verifyStoragePermissions(Activity activity) {
        try {

            //检测是否有写的权限
            int permission = ActivityCompat.checkSelfPermission(activity,
                    "android.permission.WRITE_EXTERNAL_STORAGE");
            if (permission != PackageManager.PERMISSION_GRANTED) {
                // 没有写的权限，去申请写的权限，会弹出对话框
                ActivityCompat.requestPermissions(activity, PERMISSIONS_STORAGE,REQUEST_EXTERNAL_STORAGE);
            }
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
```
2. 读取手机存储查找所有图片并存储图片路径以及其他相关信息。
- 首先，我定义了一个数据类SpacePhoto用于存储每张图片的相关信息(路径，名称等)，SpacePhoto数据类实现了Parcelable类，Parcelable用来从一个组件传输高性能数据到另一个组件，在这里，我们将图片的URL从相册的缩略图界面传递至SpacePhotoActivity。SpacePhoto数据类定义如下：
    ``` java
    public class SpacePhoto implements Parcelable {

        private String mUrl;
        private String mTitle;

        public SpacePhoto(String url, String title) {
            mUrl = url;
            mTitle = title;
        }

        protected SpacePhoto(Parcel in) {
            mUrl = in.readString();
            mTitle = in.readString();
        }

        public static final Creator<SpacePhoto> CREATOR = new Creator<SpacePhoto>() {
            @Override
            public SpacePhoto createFromParcel(Parcel in) {
                return new SpacePhoto(in);
            }

            @Override
            public SpacePhoto[] newArray(int size) {
                return new SpacePhoto[size];
            }
        };

        public String getUrl() {
            return mUrl;
        }

        public void setUrl(String url) {
            mUrl = url;
        }

        public String getTitle() {
            return mTitle;
        }

        public void setTitle(String title) {
            mTitle = title;
        }


        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel parcel, int i) {
            parcel.writeString(mUrl);
            parcel.writeString(mTitle);
        }
    }
    ```
- 然后是使用ContentResolver组件查询手机的所有图片，代码如下：
    ``` java
    Uri mImageUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
            String[] projImage = { MediaStore.Images.Media._ID
                    , MediaStore.Images.Media.DATA
                    ,MediaStore.Images.Media.SIZE
                    ,MediaStore.Images.Media.DISPLAY_NAME};
            Cursor mCursor = getActivity().getContentResolver().query(mImageUri,
                    projImage,
                    MediaStore.Images.Media.MIME_TYPE + "=? or " + MediaStore.Images.Media.MIME_TYPE + "=?",
                    new String[]{"image/jpeg", "image/png"},
                    MediaStore.Images.Media.DATE_MODIFIED+" desc");

            if( mCursor != null )
            {
                while(mCursor.moveToNext()){
                    String path = mCursor.getString(mCursor.getColumnIndex(MediaStore.Images.Media.DATA));
                    String displayName = mCursor.getString(mCursor.getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME));
                    all_photo_set.add(new SpacePhoto(path,displayName)); //将获取到的路径加入路径集合
    ```
3. 成功获取图片的路径集合后，根据路径加载图片将所有图片展示出来
- 实现图片展示列表<br/>
使用android提供的初始接口来根据图片url加载图片是比较麻烦的，首先要根据url获取图片的真实路径，再根据真实路径获取bitmap数据类型的图片，最后再通过imageview控件展示出来；其次还有图片加载的性能问题，因为图片展示列表要求快速加载系统中的所有图片。针对以上问题，我使用了一个第三方的Android开源库Glide。Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的具体使用方法如下：
    - 在build.gradle文件中添加以下依赖：
    ```java
    // Glide
    compile 'com.github.bumptech.glide:glide:3.7.0'
    ```
    - 通过图片url加载图片
    ```java
    Glide.with(mContext) //传递上下文
                .load(spacePhoto.getUrl()) // 目录路径或者URI或者URL
                .centerCrop() // 图片有可能被裁剪
                .placeholder(R.drawable.error) //一个本地APP资源id，在图片被加载前作为占位的图片
                .into(imageView); // 要放置图片的目标imageView控件
    ```
    使用Recyclerview来制作图片展示列表，Recyclerview具体用法如下：
    - 在build.gradle文件中添加以下依赖：
    ``` java
    // Recyclerview
    compile 'com.android.support:recyclerview-v7:25.1.1'
    ```
    - 自定义ImageGalleryAdapter，要求继承RecyclerView.Adapter类，具体代码如下：
    ```java
    class ImageGalleryAdapter extends RecyclerView.Adapter<ImageGalleryAdapter.MyViewHolder>  {

    private ArrayList<SpacePhoto> mSpacePhotos;
    private Context mContext;

    @Override
    public ImageGalleryAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {

        Context context = parent.getContext();
        LayoutInflater inflater = LayoutInflater.from(context);
        View photoView = inflater.inflate(R.layout.item_photo, parent, false);
        ImageGalleryAdapter.MyViewHolder viewHolder = new ImageGalleryAdapter.MyViewHolder(photoView);
        return viewHolder;
    }

    @Override
    public void onBindViewHolder(ImageGalleryAdapter.MyViewHolder holder, int position) {

        SpacePhoto spacePhoto = mSpacePhotos.get(position);
        ImageView imageView = holder.mPhotoImageView;
        Glide.with(mContext) //传递上下文
                .load(spacePhoto.getUrl()) // 目录路径或者URI或者URL
                .centerCrop() // 图片有可能被裁剪
                .placeholder(R.drawable.error) //一个本地APP资源id，在图片被加载前作为占位的图片
                .into(imageView); // 要放置图片的目标imageView控件
    }

    @Override
    public int getItemCount() {
        return (mSpacePhotos.size());
    }

    public class MyViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener {

        public ImageView mPhotoImageView;
        public MyViewHolder(View itemView) {
            super(itemView);
            mPhotoImageView = (ImageView) itemView.findViewById(R.id.iv_photo);
            itemView.setOnClickListener(this);
        }

        @Override
        public void onClick(View view) {

            int position = getAdapterPosition();
            if(position != RecyclerView.NO_POSITION) {
                SpacePhoto spacePhoto = mSpacePhotos.get(position);
                String url = spacePhoto.getUrl();
                Intent intent = new Intent(mContext, SpacePhotoActivity.class);
                Bundle bundle = new Bundle();
                bundle.putString("url",url);
                intent.putExtras(bundle);
                mContext.startActivity(intent);
            }
        }
    }

    public ImageGalleryAdapter(Context context, ArrayList<SpacePhoto> spacePhotos) {
        mSpacePhotos = new ArrayList<>();
        mContext = context;
        mSpacePhotos = spacePhotos;
    }
    }
    ```
    在fragement1显示图片展示列表，需要在PageFragment1.java文件的onCreateView函数返回一个View，该View加载的是fragment_page1 Laytout;并且，需要在onCreateView函数里设置Recyclerview的Adapter，具体代码如下：
    ``` java
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, // 系统会在Fragment首次绘制其用户界面时调用此方法
                             @Nullable Bundle savedInstanceState) {

        View root = inflater.inflate(R.layout.fragment_page1,container,false);

        search_all_picture();
        app = (MyApplication)getMyApplication();
        app.set_all_photo_set(all_photo_set); //放到Application中
        app.set_all_album(all_album);

        RecyclerView.LayoutManager layoutManager = new GridLayoutManager(getActivity(), 2);
        RecyclerView recyclerView = (RecyclerView) root.findViewById(R.id.rv_images_1);
        recyclerView.setHasFixedSize(true);
        recyclerView.setLayoutManager(layoutManager);

        ImageGalleryAdapter adapter = new ImageGalleryAdapter(getActivity(), all_photo_set);
        //调用这个函数的时候SpacePhoto并不是空的
        recyclerView.setAdapter(adapter);
        return root;
    }
    ```
    fragment_page1.xml布局文件如下：
    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

    <android.support.v7.widget.RecyclerView
        android:id="@+id/rv_images_1"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>

    </android.support.design.widget.CoordinatorLayout>
    ```
- 单击图片进入图片展示页面<br/>
我使用SpacePhotoActivity用于实现图片展示页面，在ImageGalleryAdapter类中定义内部类MyViewHolder实现View.OnClickListener，并重载onclick函数如下：
    ```java
    @Override
        public void onClick(View view) {

            int position = getAdapterPosition();
            if(position != RecyclerView.NO_POSITION) {
                SpacePhoto spacePhoto = mSpacePhotos.get(position);
                String url = spacePhoto.getUrl();
                Intent intent = new Intent(mContext, SpacePhotoActivity.class);
                Bundle bundle = new Bundle();
                bundle.putString("url",url);
                intent.putExtras(bundle);
                mContext.startActivity(intent);
            }
        }
    ```
    每次在图片点击列表单击某个图片，则跳转到SpacePhotoActivity并展示被点击的图片，这里使用Intent中传递的是被点击图片的url,在SpacePhotoActivity中根据传递过来的图片url加载图片，代码如下：
    ``` java
        mImageView = (ImageView) findViewById(R.id.image);
            Intent intent = getIntent();
            Bundle bundle = intent.getExtras();
            String url = bundle.getString("url");
        Glide.with(this)
                .load(url)
                .asBitmap()
                .error(R.drawable.error)
                .into(mImageView);
                
    ```
到这里我们完成了读取手机中的所有照片并将其展示出来的功能。
<hr />





